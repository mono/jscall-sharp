The AspNetEdit XPCOM DOM Wrappers
=================================
A word of warning - this is a bit hacky, but will have to do until someone comes up with an XPConnect interface for Mono. The aim for now is to use a minimum of Gtk and XPCOM interop code to reuse existing components and simplify debugging.

We have two functions, PlaceFunctionCall and CollectFunctionCall. The document must contain a single node in the root called <aspnetcomm>, which contains the data to be communicated between C# and JavaScript, and these functions modify and read its contents. 

The mechanism of invoking a C# method from JavaScript is as follows:
  1. A JavaScript function representing the C# method is called. If it has a return value, it registers a callback function with a handler.
  2. It calls a helper function that puts the data in the <aspnetcomm> node and sets the window 'status'. As Gecko# has no status bar this misuse doesn't adversely affect anything and is not visible to the user.
  3. The modified Gecko# control catches the ECMAStatus event that is raised, reads and deletes the function call from the DOM using CollectFunctionCall, and calls the relevant C# method.
  4. If there is a return value, a callback is placed in the reverse direction.

The reverse call is simple too:
  1. A C# method of the modified Gecko# control representing a JavaScript function is called, and it writes to the DOM using PlaceFunctionCall. If it has a return value, it registers a callback delegate with a handler.
  2. This raises the DOMNodeInserted event in JavaScript, which is caught by a handler.
  3. The handler passes the arguments to the appropriate function.
  4. If there is a return value, a callback is placed in the reverse direction.

Outbound (JS->C#) method calls are represented as a child of <aspnetcomm>, and are of the following form:
<outfunction call="functionName" args="encodedListOfArguments" >
Inbound calls are of the form:
<infunction call="functionName" args="encodedListOfArguments" >
